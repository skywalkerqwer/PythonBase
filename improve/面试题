## 				常见面试题

##### 1、x='abc',y='def',z=['d','e','f'],分别求出x.join(y)和x.join(z)返回的结果?

~~~python
x='abc'
y='def'
z=['d','e','f']
x.join(y)#dabceabcf
x.join(z)#dabceabcf
~~~

##### 2、请写出一段Python 代码实现删除一个list 里面的重复元素?

~~~Python
1 = ['b'，'c'，'d'，'b'，'c'，'a'，'a']
方法一：内置set
   l2 = list(set(l))
   print(l2)#会改变原来的顺序
方法二：
    l1=[]
	for i in l1:
		if not i in l2:
 		l2.append(i)#不改变
    #[l2.append(i) for i in l1 if not i in l2]
方法三：
     l1 = ['b','c','d','b','c','a','a']
	 l2 = list(set(l1))
	 l2.sort()
	 print(l2)
方法四：
	 l1 = ['b','c','d','b','c','a','a']
	 l2 = sorted(set(l1))
	 print（l2）
~~~

##### 3、代码分析

~~~Python
L=[1,2,3]
def f(n=0,lst=[]):
    lst.append(n)
    print(lst)
f(4,L)#[1, 2, 3, 4]
f(5,L)#[1, 2, 3, 4, 5]
f(100)#[100]
f(200)#打印结果[100,200]
#说明，函数的默认参数属于函数，它不会因函数调用结束而销毁
#以上函数可以写为：
def f(n=0,lst=None):
    if lst is None:#此处可以消除默认参数一直存在的问题
        lst.append(n)
        print(lst)
~~~

~~~Python
L=[1,2,3]
def f1(x):
    x=[4,5,6]#赋值语句会创建或改变变量的绑定关系

print(L)#[1, 2, 3]
f1(L)
print(L)#[1, 2, 3]

def f2(x):
    x.extend([7,8,9])
f2(L)
print(L)#[1, 2, 3, 7, 8, 9]
#扩展：
#list.append(object) 向列表中添加一个对象object
#list.extend(sequence) 把一个序列seq的内容添加到列表中
总结：
当列表作为参数时，在函数中如果将列表赋值给变量，对变量进行操作时，则外部的列表不会发生变化；
如果直接对列表进行修改时，外部的列表会发生改变；
如果对列表绑定的变量进行赋值操作，外部的列表不会发生改变
~~~

##### 4、Python里面如何拷贝一个对象？（赋值、浅拷贝、深拷贝的区别）

~~~Python
1）赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。
2）浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改
其中一个对象，另外一个也会修改改变）{1,完全切片方法；2，工厂函数，如 list()；3，copy 模块
的 copy()函数}。
3）深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改
变）{copy 模块的 copy.deepcopy()函数}。
（copy：浅拷贝，只拷贝父对象，不会拷贝对象的内部子对象。
       改变内部子对象，则拷贝对象与被拷贝对象一起改变。
 deepcopy：深拷贝，拷贝对象及其子对象。
       改变内部子对象，只改变被修改的对象，另一个不会跟着改变）
~~~

##### 5、Python常用内置模块

​    [http://blog.51cto.com/yht1990/1845737]

##### 6、在python中, list, tuple, dict, set有什么区别, 主要应用在什么样的场景？

##### 7、Python中使用%与.format格式化文本

##### 8、Python的内存管理机制及调优手段？

~~~Python
内存管理机制：引用计数、垃圾回收、内存池。
引用计数：
引用计数是一种非常高效的内存管理手段， 当一个 Python 对象被引用时其引用计数增加 1， 当
其不再被一个变量引用时则计数减 1. 当引用计数等于 0 时对象被删除。
垃圾回收 ：
1. 引用计数
引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当 Python 的某
个对象的引用计数降为 0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如
某个新建对象，它被分配给某个引用，对象的引用计数变为 1。如果引用被删除，对象的引用计数为 0，
那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了
2. 标记清除
如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被
回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。所以先将循环引
用摘掉，就会得出这两个对象的有效计数。
3. 分代回收
从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统中
总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾回
收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额外
操作。
举个例子：
当某些内存块 M 经过了 3 次垃圾收集的清洗之后还存活时，我们就将内存块 M 划到一个集合A
中去，而新分配的内存都划分到集合 B 中去。当垃圾收集开始工作时，大多数情况都只对集合 B 进行
垃圾回收，而对集合 A 进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理
的内存少了，效率自然就提高了。在这个过程中，集合 B 中的某些内存块由于存活时间长而会被转移
到集合 A 中，当然，集合 A 中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延
迟。
内存池：
1. Python 的内存机制呈现金字塔形状，-1，-2 层主要有操作系统进行操作；
2. 第 0 层是 C 中的 malloc，free 等内存分配和释放函数进行操作；
3. 第 1 层和第 2 层是内存池，有 Python 的接口函数 PyMem_Malloc 函数实现，当对象小于
256K 时有该层直接分配内存；
4. 第 3 层是最上层，也就是我们对 Python 对象的直接操作；
Python 在运行期间会大量地执行 malloc 和 free 的操作，频繁地在用户态和核心态之间进行切
换，这将严重影响 Python 的执行效率。为了加速 Python 的执行效率，Python 引入了一个内存池机
制，用于管理对小块内存的申请和释放。
Python 内部默认的小块内存与大块内存的分界点定在 256 个字节，当申请的内存小于 256 字节
时，PyObject_Malloc 会在内存池中申请内存；当申请的内存大于 256 字节时，PyObject_Malloc 的
行为将蜕化为 malloc 的行为。当然，通过修改 Python 源代码，我们可以改变这个默认值，从而改变
Python 的默认内存管理行为。
调优手段（了解）
1.手动垃圾回收
2.调高垃圾回收阈值
3.避免循环引用（手动解循环引用和使用弱引用）
~~~



​